/*
编译器如何实现 RAII 呢？它通过使用栈来实现，栈的作用域通常由花括号（{ ... }）表示。
当进入特定作用域（如函数）时，每个新变量都被推入栈中。当离开作用域时，每个变量都会从栈中弹出。
编译器必须为每个变量存储一些额外的数据，
以便安全地销毁每个值。尽管额外开销很小，通常只是额外的指针，用于需要清理的任何内容。
*/
/*
在Rust中，对象管理始终遵循RAII规则，没有例外，除非使用unsafe关键字。换句话说，
Rust保证了析构函数按预期调用。变量必须在声明时初始化，并且当变量超出作用域时，
它总是通过析构函数进行销毁（稍后我们将讨论）。尽管这可能偶尔会被抽象或间接层所掩盖，
但对于Rust中的任何对象或变量而言，这总是正确的。对于简单变量（即不是Rc或Arc等指针的变量），
Rust的借用检查器和移动语义使得推断变量或对象何时超出作用域，以及何时销毁它们相对容易。
*/

/*
RAII在Rust中被广泛使用，特别是：

    Rust没有垃圾回收，内存管理是显式的。在堆上分配内存通常使用 Box 或 Vec 完成。
    对象的生命周期是确定性的，并且在编译时已知（除了使用智能指针时）。
    堆上分配的对象遵循与栈上分配的对象相同的RAII规则。
    内存管理对象利用RAII：Box 和 Vec 使用 RAII 来获取、初始化和释放内存资源。
    类似 Rc 和 Arc 的智能指针使用 RAII 来实现每次指针被克隆和销毁时的引用计数。
    RefCell 返回借用引用 Ref 和 RefMut，它们使用 RAII 来防止多个同时引用。
    几个同步原语使用 RAII：
        Mutex::lock() 在成功时返回 MutexGuard，它是一个基于 RAII 的锁保护，当它被销毁时自动解锁互斥锁。
        RwLock 在获得共享读取或独占写入访问权限时分别返回 RwLockReadGuard 或 RwLockWriteGuard，用于读写锁。
        Condvar 在等待条件变量时需要一个 MutexGuard
*/
/*
Rust总是在所有对象超出作用域时调用它们的析构函数，因此你不需要手动调用 drop()，
而且你不能在不使用 unsafe 的情况下重写这种行为（也就是说，你不能阻止Rust调用析构函数）。
*/
