## 环境列表
每一个进程都有与其相关的称之为环境列表（environment list）的字符串数组，或简称为环
境（environment） 。其中每个字符串都以名称=值（name=value）形式定义。因此，环境是“名称
-值”的成对集合，可存储任何信息。常将列表中的名称称为环境变量（environment variables）。

**新进程在创建之时，会继承其父进程的环境副本。**
父、子进程均可更改各自的环境变量，且这些变更对对方而言不再可见。

环境变量的常见用途之一是在 shell 中。通过在自身环境中放置变量值，shell 就可确保把
这些值传递给其所创建的进程，并以此来执行用户命令。

大多数 shell 使用 export 命令向环境中添加变量值。在 bash shell 和 Korn shell 中，可以简写为。
在 C shell 中，使用的则是 setenv 命令。
上述命令把一个值永久地添加到 shell 环境中，此后这个 shell 创建的所有子进程都将继承此
环境。在任一时刻，可以使用 unset 命令撤销一个环境变量（在 C shell 中则使用 unsetenv 命令） 。

通过 Linux 专有的/proc/PID/environ 文件检查任一进程的环境列表，
每一个 “NAME=value” 对都以空字节终止。

**在 C 语言程序中，可以使用全局变量 char * * environ 访问环境列表。（C 运行时启动代码定义了该变量并以环境列表位置为其赋值。
）environ 与 argv 参数类似，指向一个以 NULL 结尾的指针列表，每个指针又指向一个以空字节终止的字符串。**

### 检索环境的值，修改环境的值
- getenv()：函数能够从进程环境中检索单个值。
- putenv()：函数向调用进程的环境中添加一个新变量，或者修改一个已经存在的变量值。
- setenv()：函数为形如 name=value 的字符串分配一块内存缓冲区，并将 name 和 value 所指
向的字符串复制到此缓冲区，以此来创建一个新的环境变量。
- unsetenv()：函数从环境中移除由 name 参数标识的变量。
- clearenv()：清除整个环境，然后以所选值进行重建。

## 执行非局部跳转：setjmp()和 longjmp()
C 语言的 goto 语句存在一个限制，即不能从当前函数跳转到另一函数。

考虑错误处理中经常出现的如下场景：在一个深度嵌套的函数调用中发生 了错误，需要放弃当前任务，从多层函数调用中返回，并在较高层级的函数中继续执行（也
许甚至是在 main()中） 。要做到这一点，可以让每个函数都返回一个状态值，由函数的调用者检查并做相应处理。

```c
#include <setjmp.h>
int setjmp(jmp_buf env);
void longjmp(jmp_buf env, int val);
```
setjmp()调用为后续由 longjmp()调用执行的跳转确立了跳转目标。该目标正是程序发起setjmp()调用的位置。

